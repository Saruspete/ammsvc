# vim: ft=sh

# Adrien Mahieux - SVC Generic lib v0.1

if [[ -z "$MYPATH" ]] || [[ -z "$MYSELF" ]] || [[ -z "$MYCALL" ]]; then
	echo "Your environemnt is not safe to use this lib..."
	exit 1
fi

# Ensure a safe environment
set -o nounset
set -o noclobber

export LC_ALL="C"
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:$PATH"
unset LD_LIBRARY_PATH


# Set my path according to these
typeset -r APP_NAME="${MYCALL##*/}"
typeset -r APP_PACK="${APP_NAME%%-*}"
typeset -r APP_BASE="$(readlink -f $MYPATH/../apps/${APP_PACK})"
typeset -r DAT_BASE="$(readlink -f $MYPATH/../data/${APP_PACK})"
typeset -r SRC_BASE="$(readlink -f $MYPATH/../srcs/${APP_NAME})"
typeset -r TMP_BASE="$(readlink -f $MYPATH/../temp/${APP_NAME})"
typeset -r TMP_PIDS="${TMP_BASE}/pids"
typeset -r LOG_BASE="${DAT_BASE}/logs"

# Sanity checks
[[ -z "$APP_BASE" ]] && { echo >&2 "Unable to find APP_BASE value"; exit 1; }
[[ -z "$LOG_BASE" ]] && { echo >&2 "Unable to find LOG_BASE value"; exit 1; }
[[ -z "$DAT_BASE" ]] && { echo >&2 "Unable to find DAT_BASE value"; exit 1; }
[[ -z "$TMP_BASE" ]] && { echo >&2 "Unable to find TMP_BASE value"; exit 1; }
[[ -e "$APP_BASE" ]] || { echo >&2 "Missing required folder '$APP_BASE'"; exit 1; }
[[ -d "$TMP_BASE" ]] || mkdir -p "$TMP_BASE"
[[ -d "$LOG_BASE" ]] || mkdir -p "$LOG_BASE"



#
typeset RUN_VERS="${RUN_VERS:-current}"
typeset RUN_BASE="$APP_BASE/${APP_NAME}-${RUN_VERS}"

export RUN_VERS RUN_BASE DAT_BASE SRC_BASE TMP_BASE LOG_BASE

# To be overriden by script
typeset RUN_USER="${RUN_USER:-}"
typeset RUN_BIN="${RUN_BIN:-}"
typeset RUN_OPTSTART="${RUN_OPTSTART:-}"
typeset RUN_OPTSTOP="${RUN_OPTSTOP:-}"
typeset RUN_OPTPID="${RUN_OPTPID:-}"
typeset RUN_DAEMON=""

# Verbosity
typeset -i LOG_VERB="1"
typeset -i _LOG_DEPTH=0

typeset CESC="\033["
typeset CRST="${CESC}0m"
typeset CRED="${CESC}91m"
typeset CGRN="${CESC}92m"
typeset CYEL="${CESC}93m"
typeset CBLU="${CESC}94m"
typeset CPUR="${CESC}95m"
typeset CCYA="${CESC}96m"
typeset CWHI="${CESC}96m"

function char_repeat {
	typeset -i time="${1:-1}";
	typeset char="${2:- }";
	seq -s "$char" $(($time+1)) | tr -d '[:digit:]'
}

function log {
	typeset lvl="$1"; shift
	typeset lvlcol="$lvl"
	case $lvl in
		ERR) lvlcol="${CRED}$lvl${CRST}" ;;
		WRN) lvlcol="${CYEL}$lvl${CRST}" ;;
		INF) lvlcol="${CGRN}$lvl${CRST}" ;;
		DBG) lvlcol="${CBLU}$lvl${CRST}" ;;
	esac

	# Padding for logs, depending on the step we are in.
	# But don't add it for debug, already done from PS4 1rst char
	typeset pad="$(char_repeat $(($_LOG_DEPTH*2)))"
	[[ "$lvl" == "DBG" ]] && pad=""

	# Read stdin
	if [[ "$1" = "-"  ]]; then

		while read line; do
			# Skip the ending "set +x" of dbg
			[[ $line =~ .+\ set\ \+x$ ]] && continue
			if [[ -t 1 ]]; then
				echo -e "[$(date '+%H:%M:%S')][$lvlcol]$pad $line"
			else
				echo "[$(date '+%Y-%m-%d_%H:%M:%S')][$lvl]$pad $line"
			fi
		done

	# Standard line
	else
		# Use color & short date if stdout (1) is pure tty (not piped)
		if [[ -t 1 ]]; then
			echo -e "[$(date '+%H:%M:%S')][$lvlcol]$pad $@"
		else
			echo "[$(date '+%Y-%m-%d_%H:%M:%S')][$lvl]$pad $@"
		fi
	fi
}
function log_err { log "ERR" "$@"; }
function log_wrn { log "WRN" "$@"; }
function log_inf { log "INF" "$@"; }
function log_dbg {
	#LOG_DBGSTACK[$_LOG_DEPTH]+="$@"

	# Only send to log on verbose level
	if [[ "$LOG_VERB" -ge 2 ]]; then
		log "DBG" "$@"
	# Else, we must consume stdin or bash will fail (and add to stack nonetheless)
	else
		if [[ "$1" == "-" ]]; then
			while read line; do
				echo "$line" >> "${LOG_DBGFILE}.${_LOG_DEPTH}"
			done
		else
			echo "$@" >> "${LOG_DBGFILE}.${_LOG_DEPTH}"
		fi
	fi
}

# Log xtrace
function log_xtr {
	set +x
	log_dbg -
}


function log_stepnew {
	log_inf "STEP NEW ($_LOG_DEPTH): $@"
	_LOG_DEPTH+=1
	# Clean old stack
	>| "${LOG_DBGFILE}.${_LOG_DEPTH}"
	#LOG_DBGSTACK[$_LOG_DEPTH]=""
}
function log_stepend {
	_LOG_DEPTH+=-1
	log_inf "STEP END ($_LOG_DEPTH): $@"
}

function log_stackdump {
	typeset -i deep="${1:-1}"

	# Cannot go before deep 0
	[[ $deep -gt $_LOG_DEPTH ]] && deep=$_LOG_DEPTH

	while [[ $deep -ge 0 ]]; do
		typeset -i d=$(( $_LOG_DEPTH - $deep ))
		#echo "${LOG_DBGSTACK[$d]}"
		cat "${LOG_DBGFILE}.${d}"
		deep+=-1
	done
}

function log_cleanup {
	# remove temporary stack files
	rm -f $LOG_DBGFILE.[0-9]*
}

# Debugging logs (beware, will be async from other standard log_ calls !)
#typeset -a LOG_DBGSTACK
typeset LOG_DBGFILE="$LOG_BASE/svc.${APP_NAME}.$$.dbg"
exec 99> >(log_xtr; wait)
export PS4=' (${BASH_SOURCE##*/}::${FUNCNAME[0]:-main}::$LINENO)  '
BASH_XTRACEFD=99


function normalize_linereturn {
	typeset file="$1"

	# Inspired from https://www.linuxquestions.org/questions/programming-9/merge-lines-in-a-file-using-sed-191121/
	grep -Pv '^\s*#' "$file" \
	| sed -e :a -e N -Ee 's/\\\s*(#.*)?\n^\s*/ /' -e ta
}



function is_set {   type "$1" >/dev/null; }
function is_func {  [[ "$(type -t "$1")" == "function" ]]; }
function is_alias { [[ "$(type -t "$1")" == "alias" ]]; }

# Try to run as user
function user_run {
	typeset runas="$1"; shift
	typeset curruser="$(user_current)"
	typeset ret=0

set -x
	# Exec from stdin
	if [[ "$@" = "-" ]]; then
		
		# If no user specified, or we already are correct one...
		if [[ -z "$runas" ]] || [[ "$runas" = "$curruser" ]]; then
			eval "$(cat)"
			ret=$?
			
		# root... yay !
		elif [[ "$curruser" = "root" ]]; then
			cat | su -m "$runas"
			ret=$?
		else
			log_err "Cannot change from user $curruser to user $runas"
			ret=4
		fi
		
	# Standard binary to run
	else

		# No user specified, or already correct user
		if [[ -z "$runas" ]] || [[ "$runas" = "$curruser" ]]; then
			log_dbg "Using eval to run as '$runas' cmd: '$@'"
			eval "$@"
			ret=$?

		# root... yay !
		elif [[ "$curruser" = "root" ]]; then
			log_dbg "Using su to run as '$runas' cmd: '$*'"
			# I need to flatten
			su -m -c "$*" "$runas"
			ret=$?

		# Maybe handle sudo ?
		elif sret="$(sudo -nl 2>/dev/null|awk 'p==1; /may run the following commands/{p=1;}')" && [[ -n "$sret" ]]; then
			log_dbg "Using sudo to run as '$runas' cmd: '$@'"
			# maybe should parse $sret output more...
			sudo -n -u "$runas" "$@"
			ret=$?

		# Fails...
		else
			log_err "Cannot exec '$@' as user $runas from user $curruser"
			ret=4
		fi
	fi
set +x

	return $ret
}

function user_current {
	id -un
}

function user_owner {
	typeset file="$1"

	stat -c '%U' $file

}

# Standard start
function amsvc_start {

	# Use global opts if available
	typeset opts="${RUN_OPTSTART:-}"
	typeset pidf=""

	# If argument provided, use these to override
	[[ -n "${1:-}" ]] && {
		opts="$@"
	}


	#
	# User defined startup func, just use it
	#
	if is_func "run_start"; then
		log_inf "Starting with custom run_start function"
		run_start "$opts"
		log_inf "Result: $?"
		return $?

	#
	# Variables defined for standard management
	#
	elif [[ -n "$RUN_BIN" ]]; then

		# Runas specified user. If not defined, use owner of the binary
		typeset runas="${RUN_USER:-$(stat -c '%U' "$RUN_BIN")}"

		#
		# PIDFILE management
		#
		[[ -n "$RUN_OPTPID" ]] && {
			pidf="$(amsvc_getpidfile)"
			opts+=" $RUN_OPTPID $pidf"
		}

		# If pidfile, check it has access to the file
		[[ -n "$pidf" ]] && [[ -e "$pidf" ]] && {

			# Does the file already belong to target user
			[[ "$(user_owner "$pidf")" != "$runas" ]] && {
				chown $runas: "$pidf" || {
					log_err "Unable to chown '$runas' '$pidf'. The app may fail or be unmanageable"
				}
			}
		}

		#
		# Logfile and daemon management
		#
		[[ -n "$RUN_DAEMON" ]] && {
			typeset logfile="$(amsvc_getlogfile)"
			log_inf "Daemonizing and sending logs to $logfile"
			opts+=" >>$logfile 2>&1 0>/dev/null &"
		}

		log_inf "Starting with \$RUN_BIN var ($RUN_BIN)"
		typeset out=""
		typeset ret=""

		out="$(user_run "$RUN_USER" "$RUN_BIN" $opts 2>&1)"
		ret=$?


		# Check return value
		if [[ $ret -ne 0 ]]; then
			log_err "Service start return: $ret. Output:\n$out"
			log_dbg "$(log_stackdump)"
		else
			log_inf "Result: $ret"
		fi
		return $ret

	# Nothing...
	else
		log_err "Cannot use generic start: No function 'run_start' and no var 'RUN_BIN' defined"
		return 1
	fi

}

# Standard stop
function amsvc_stop {
	:
}

function amsvc_getpidfile {
	# Create base folder if needed
	[[ -d "$TMP_PIDS" ]] || mkdir -p "$TMP_PIDS"

	# Return standard pid path
	echo "${TMP_PIDS}/${APP_NAME}.pid"
}

function amsvc_getlogfile {
	[[ -d "$LOG_BASE" ]] || mkdir -p "$LOG_BASE"

	echo "$LOG_BASE/daemon.log"
}

function amsvc_isrunning {

	# Check if we have a valid PID File
	typeset pidfile="$(amsvc_getpidfile)"
	[[ -s "$pidfile" ]] && {
		typeset pid="$(cat "$pidfile" 2>/dev/null)"
		# PIDs < 100 are so unlikely (used by kthreads) we shouldn't even try
		[[ -n "$pid" ]] && [[ "$pid" -gt 100 ]] && {
			[[ -e "/proc/$pid" ]]
			return $?
		}
	}

	# No pid file, try if we have a RUN_BIN var
	[[ -n "$RUN_BIN" ]] && {
		:
	}

	return 1
}

function amsvc_upgrade {
	:
}

# Parse global options
function amsvc_parseopt {

	while [[ -n "${1:-}" ]]; do
		case $1 in
			-v|--verbose)
				LOG_VERB+=1
				shift
				;;

			*)
				break;
				;;
		esac
	done
}


# Main processing option
function amsvc_main {

	# First parse common options
	amsvc_parseopt "$@"

	act="${1:-}"; shift

	#
	case "$act" in
		start)
			amsvc_isrunning && log_wrn "already started"
			amsvc_start "$@"
			;;
		stop)
			amsvc_isrunning || log_wrn "already stopped"
			amsvc_stop "$@"
			;;
		restart)
			amsvc_isrunning && amsvc_stop "$@"
			amsvc_isrunning || amsvc_start "$@"
			;;
		status)
			echo "Status of ${APP_NAME}:"
			amsvc_isrunning
			;;

		upgrade)
			amsvc_upgrade "$@"
			;;
		*)
			log_err "Usage: $0 <start|stop|restart|status|zap>"
			exit 1
			;;
	esac
}

function file_set_key {
	:
}
