# vim: ft=sh

# Adrien Mahieux - SVC Generic lib v0.1

if [[ -z "$MYPATH" ]] || [[ -z "$MYSELF" ]] || [[ -z "$MYCALL" ]]; then
	echo "Your environemnt is not safe to use this lib..."
	exit 1
fi

# Ensure a safe environment
set -o nounset
set -o noclobber

export LC_ALL="C"
export PATH="/bin:/sbin:/usr/bin:/usr/sbin:$PATH"
unset LD_LIBRARY_PATH


# Set my path according to these
typeset -r APP_NAME="${MYCALL##*/}"
typeset -r APP_PACK="${APP_NAME%%-*}"
typeset    APP_BASE="$MYPATH/../apps/${APP_PACK}"
typeset    DAT_BASE="$MYPATH/../data/${APP_PACK}/${APP_NAME}"
typeset    SRC_BASE="$MYPATH/../srcs/${APP_PACK}/${APP_NAME}"
typeset    TMP_BASE="$MYPATH/../temp/${APP_PACK}/${APP_NAME}"

# Create folders, they may be used by update procedures
for p in "$APP_BASE" "$DAT_BASE" "$SRC_BASE" "$TMP_BASE"; do
	[[ -d "$p" ]] || mkdir -p "$p"
done

# Clean the paths for absolute value
typeset -r APP_BASE="$(readlink -f $APP_BASE)"
typeset -r DAT_BASE="$(readlink -f $DAT_BASE)"
typeset -r SRC_BASE="$(readlink -f $SRC_BASE)"
typeset -r TMP_BASE="$(readlink -f $TMP_BASE)"
typeset -r TMP_PIDS="${TMP_BASE}/pids"
typeset -r LOG_BASE="${DAT_BASE}/logs"

# Create folders, they may be used by update procedures
for p in "$TMP_PIDS" "$LOG_BASE"; do
	[[ -d "$p" ]] || mkdir -p "$p"
done

# Sanity checks
[[ -z "$APP_BASE" ]] && { echo >&2 "Unable to find APP_BASE value"; exit 1; }
[[ -z "$LOG_BASE" ]] && { echo >&2 "Unable to find LOG_BASE value"; exit 1; }
[[ -z "$DAT_BASE" ]] && { echo >&2 "Unable to find DAT_BASE value"; exit 1; }
[[ -z "$TMP_BASE" ]] && { echo >&2 "Unable to find TMP_BASE value"; exit 1; }
[[ -e "$APP_BASE" ]] || { echo >&2 "Missing required folder '$APP_BASE'"; exit 1; }

[[ -d "$TMP_BASE" ]] || mkdir -p "$TMP_BASE"
[[ -d "$LOG_BASE" ]] || mkdir -p "$LOG_BASE"



#
typeset RUN_VERS="${RUN_VERS:-current}"
typeset RUN_BASE="$APP_BASE/${APP_NAME}-${RUN_VERS}"

export RUN_VERS RUN_BASE DAT_BASE SRC_BASE TMP_BASE LOG_BASE

# To be overriden by script
typeset RUN_USER="${RUN_USER:-}"
typeset RUN_BIN="${RUN_BIN:-}"
typeset RUN_CFG="${RUN_CFG:-}"
typeset RUN_OPTSTART="${RUN_OPTSTART:-}"
typeset RUN_OPTSTOP="${RUN_OPTSTOP:-}"
typeset RUN_OPTPID="${RUN_OPTPID:-}"
typeset RUN_DAEMON=""

# Verbosity
typeset -i LOG_VERB="1"
typeset -i _LOG_DEPTH=0
# Interactive
typeset -i _LOG_INTERACT=0
[[ -t 0 ]] && _LOG_INTERACT=1

typeset CESC="\033["
typeset CRST="${CESC}0m"
typeset CRED="${CESC}91m"
typeset CGRN="${CESC}92m"
typeset CYEL="${CESC}93m"
typeset CBLU="${CESC}94m"
typeset CPUR="${CESC}95m"
typeset CCYA="${CESC}96m"
typeset CWHI="${CESC}96m"


##############################################################################
#
# UI Stubs
#
##############################################################################

function char_repeat {
	typeset -i time="${1:-1}";
	typeset char="${2:- }";
	seq -s "$char" $(($time+1)) | tr -d '[:digit:]'
}

##############################################################################
#
# Logging functions
#
##############################################################################
function log {
	typeset lvl="$1"; shift
	typeset lvlcol="$lvl"
	case $lvl in
		ERR) lvlcol="${CRED}$lvl${CRST}" ;;
		WRN) lvlcol="${CYEL}$lvl${CRST}" ;;
		INF) lvlcol="${CGRN}$lvl${CRST}" ;;
		DBG) lvlcol="${CBLU}$lvl${CRST}" ;;
	esac

	# Padding for logs, depending on the step we are in.
	# But don't add it for debug, already done from PS4 1rst char
	typeset pad="$(char_repeat $(($_LOG_DEPTH*2)))"
	[[ "$lvl" == "DBG" ]] && pad=""

	# If stdin (0) is a tty, just use shortdate
	typeset datefmt='+%H:%M:%S'
	[[ $_LOG_INTERACT -eq 0 ]] && datefmt='+%Y-%m-%d_%H:%M:%S'

	# Read stdin
	if [[ "$1" = "-"  ]]; then

		while read line; do
			# Skip the ending "set +x" of dbg
			[[ $line =~ .+\ set\ \+x$ ]] && continue
			if [[ $_LOG_INTERACT -eq 1 ]]; then
				echo >&98 -e "[$(date "$datefmt")][$lvlcol]$pad $line"
			else
				echo >&98 "[$(date "$datefmt")][$lvl]$pad $line"
			fi
		done

	# Standard line
	else
		# Use color & short date if stdout (1) is pure tty (not piped)
		if [[ $_LOG_INTERACT -eq 1 ]]; then
			echo >&98 -e "[$(date "$datefmt")][$lvlcol]$pad $@"
		else
			echo >&98 "[$(date "$datefmt")][$lvl]$pad $@"
		fi
	fi
}
function log_err { log "ERR" "$@"; }
function log_wrn { log "WRN" "$@"; }
function log_inf { log "INF" "$@"; }
function log_dbg {
	#LOG_DBGSTACK[$_LOG_DEPTH]+="$@"

	# Only send to log on verbose level
	if [[ "$LOG_VERB" -ge 2 ]]; then
		log "DBG" "$@"
	# Else, we must consume stdin or bash will fail (and add to stack nonetheless)
	else
		if [[ "$1" == "-" ]]; then
			while read line; do
				echo "$line" >> "${LOG_DBGFILE}.${_LOG_DEPTH}"
			done
		else
			echo "$@" >> "${LOG_DBGFILE}.${_LOG_DEPTH}"
		fi
	fi
}

# Log xtrace (run in another process)
function log_xtr {
	set +x
	log_dbg -
}


function log_stepnew {
	log_inf "STEP NEW ($_LOG_DEPTH): $@"
	_LOG_DEPTH+=1
	# Clean old stack
	>| "${LOG_DBGFILE}.${_LOG_DEPTH}"
	#LOG_DBGSTACK[$_LOG_DEPTH]=""
}
function log_stepend {
	_LOG_DEPTH+=-1
	log_inf "STEP END ($_LOG_DEPTH): $@"
}

function log_stackdump {
	typeset -i deep="${1:-1}"

	# Cannot go before deep 0
	[[ $deep -gt $_LOG_DEPTH ]] && deep=$_LOG_DEPTH

	while [[ $deep -ge 0 ]]; do
		typeset -i d=$(( $_LOG_DEPTH - $deep ))
		#echo "${LOG_DBGSTACK[$d]}"
		cat "${LOG_DBGFILE}.${d}"
		deep+=-1
	done
}

function log_cleanup {
	# remove temporary stack files
	rm -f $LOG_DBGFILE.[0-9]*
}

##############################################################################
#
# Data input and normalization
#
##############################################################################

function normalize_linereturn {
	typeset file="$1"

	# Inspired from https://www.linuxquestions.org/questions/programming-9/merge-lines-in-a-file-using-sed-191121/
	grep -Pv '^\s*#' "$file" \
	| sed -e :a -e N -Ee 's/\\\s*(#.*)?\n^\s*/ /' -e ta
}

function is_set {   type "$1" >/dev/null; }
function is_func {  [[ "$(type -t "$1")" == "function" ]]; }
function is_alias { [[ "$(type -t "$1")" == "alias" ]]; }
function is_binary {
	for bin in "$@"; do
		binfound=""
		for p in ${PATH//:/ }; do
			[[ -x "$p/$bin" ]] && {
				binfound="$p/$bin"
				break
			}
		done

		# If binary was not found in $PATH, stop here
		if [[ -z "$binfound" ]]; then
			return 1
		fi
	done
	return 0
}

function file_diff {
	typeset f1="$1"
	typeset f2="$2"

	diff -y --suppress-common-lines "$f1" "$f2"
}

##############################################################################
#
# Fetching data
#
##############################################################################

function fetch_github_branch {
	typeset projectpath="$1"
	typeset branch="${2:-master}"

	# Get the atom feed, and grep the related tag...
	typeset url="https://github.com/$projectpath/commits/${branch}.atom"
	typeset out="$(fetch_http "$url" "-")"
	typeset commitid="${out#*<id>tag:github.com,2008:Grit::Commit/}"
	commitid="${commitid%%</id>*}"
	typeset commitdate="${out#*<updated>}"
	commitdate="${commitdate%%</updated>*}"

	echo "$commitdate $commitid"
	[[ -n "$commitdate" ]]
}

function fetch_github_release {
	typeset projectpath="$1"
	typeset tag="${2:-latest}"

	typeset url="https://github.com/$projectpath/releases/$tag"
	typeset out="$(fetch_http "$url" "-" "nofollow")"
	# curl will output the html with new location href
	# wget will show the redirect url
	typeset vers="$(echo "$out"| grep -Po 'releases/tag/.+[" ]' | cut -d/ -f 3 | tr -d '"')"
	echo "$vers"
	[[ -n "$vers" ]]
}

function fetch_http {
	typeset src="$1"
	typeset dst="$2"
	typeset opts="${3:-follow silent}"

	#
	# Curl
	#
	if is_binary "curl"; then
		# TODO: Manage the proxy creds
		log_inf "Fetching '$src' with curl"

		# Process special parameters
		typeset curlopts=""
		for o in ${opts:-}; do
			case $o in
				follow) curlopts+=" -L" ;;
				nofollow) curlopts="${curlopts// -L/ /}" ;;
				silent) curlopts+=" " ;;
				*) log_err "Unknown option: $o" ;;
			esac
			shift
		done

		# Do the query
		set -x
		\curl 2>&1 $curlopts -sS -f --connect-timeout 10 -o "$dst" "$src"
		ret=$?
		set +x
		return $ret

	#
	# wget
	#
	elif is_binary "wget"; then
		log_inf "Fetching '$src' with wget"

		# Process special parameters
		typeset wgetopts=""
		for o in ${opts:-}; do
			case $o in
				follow) ;;
				nofollow) wgetopts+=" --max-redirect=0" ;;
				silent) wgetopts+=" -sS" ;;
				*) log_err "Unknown fetch_http option: $o" ;;
			esac
			shift
		done

		# Do the fetch
		set -x
		\wget 2>&1 $wgetopts -O "$dst" "$src"
		ret=$?
		set +x
		return $ret

	else
		log_err "Unable to find curl not wget for fetch_http"
		return 99
	fi
}

function fetch_auto {
	typeset src="$1"
	typeset dst="${2:-$TMP_BASE/${src##*/}}"
	typeset opt="${3:-}"
	typeset ret=0


	# git: URL ends with .git  or start as git://
	if [[ $src =~ ^git:// ]] || [[ $src =~ .+\.git$ ]]; then
		if is_binary "git"; then
			(
				mkdir -p "$dst"
				cd "$dst"
				git clone "$src" .
			)
			ret=$?
		else
			log_err "Cannot find git"
			ret=99
		fi

	# scp: host:path
	elif [[ $src =~ ^[a-zA-Z0-9_\-\.]+:.+$ ]]; then
		log_wrn "scp not yet implemented"
		ret=99

	# RSYNC
	elif [[ $src =~ ^rsync:// ]]; then
		if is_binary "rsync"; then
			rsync -a "$src" "$dst"
			ret=$?
		else
			log_err "Cannot find rsync"
			ret=99
		fi

	# HTTP: curl or wget
	elif [[ $src =~ ^https?:// ]]; then

		fetch_http "$src" "$dst" "$opt"
		ret=$?

	# Local file: "./"
	elif [[ -e "$(readlink -f $src)" ]]; then
		log_inf "Fetching '$src' with cp"
		cp -r "$src" "$dst"
		ret=$?
	else
		log_err "Unable to process url '$src'"
		ret=99
	fi

	echo "$dst"
	return $ret
}

##############################################################################
#
# Application path management
#
##############################################################################
function app_getpath {
	typeset vers="${1:-$RUN_VERS}"
	echo "$APP_BASE/$APP_NAME-$vers"
}

#
# Detect most params to download & unpack from specified URL
#
function app_deploy {
	typeset vers="$1"
	typeset url="$2"
	typeset bincheck="${3:-}"

	# Prepare the target path
	typeset dstdir="$(app_getpath "$vers")"
	typeset dst="$dstdir/${url##*/}"
	mkdir -p "$dstdir"

	# Fetch the file from url (if needed)
	if ! [[ -s "$dst" ]]; then
		log_dbg "Fetching url '$url' @ '$vers' to '$dst'"
		fetch_auto "$url" "$dst"
		ret=$?

		if [[ $ret -ne 0 ]]; then
			log_err "Unable to download url '$url' to '$dst'"
			return 1
		fi
	else
		log_inf "Using existing file '$dst'"
	fi

	# Unpack the file
	app_unpack "$vers" "$dst" | log_dbg "-"

	echo "$dstdir"

	# If a bin to be checked is provided
	if [[ -n "$bincheck" ]] && ! [[ -x "$dstdir/$bincheck" ]]; then
		log_err "Unable to find '$bincheck' executable in folder '$dstdir'"
		return 1
	fi

	return 0
}

function app_unpack {
	typeset vers="$1"
	typeset src="$2"

	typeset file="${src##*/}"
	typeset path="${src%/*}"
	typeset user="${RUN_USER:-$(user_owner "$MYSELF")}"
	typeset -i ret=0

	typeset PREP_BIN=""
	typeset PREP_OPTS=""
	typeset TAR_OPTS=" -C $path "

	# Preprocessing if needed (could use -a)
	case $file in
		*tar.gz|*.tgz)   TAR_OPTS+=" -z" ;;
		*.tar.bz2|*.tbz) TAR_OPTS+=" -j" ;;
		*.tar.xz|*.txz)  TAR_OPTS+=" -J" ;;
		*.tar.lzma|*.tlzma) TAR_OPTS+=" --lzma" ;;
	esac

	# Extract raw package format (TODO: Use mime instead of file extension)
	case $file in
		# Tarball
		*.tar.?z*|*.t?z)

			# Check if we should strip the first path or not
			typeset strip=" --strip-components=1"
			while read line; do
				# If no transformation is done, we have one or more folder at root level.
				# Folders always ends with "/", even "./"
				[[ "${line##*/}" == "$line" ]] && {
					log_wrn "One or more file found at root archive. Not stripping first level"
					strip=""
					break
				}
				# If the tarball starts with "./", we need to strip it too
				[[ "${line}" =~ ^\./ ]] && {
					strip=" --strip-components=2"
				}
			done < <(\tar $TAR_OPTS -t -f "$src")

			# Add the strip (if any left)
			TAR_OPTS+=" $strip"

			# Override the owner for the same user as the calling script
			TAR_OPTS+=" --owner $user"

			# Unpack the tarball
			log_inf "Unpacking $file with tar opts: $TAR_OPTS"
			set -o pipefail
			\tar $TAR_OPTS -x -p -f "$src" 2>&1 | log_dbg -

			ret=$?
			;;

		# RPM extraction
		*.rpm)
			log_inf "Unpacking $file with rpm2cpio"
			(
				cd "$path"
				set -o pipefail
				\rpm2cpio "$src" | cpio -idm 2>&1 | log_dbg -
			)
			ret=$?
			;;

		# Unmanaged packing format
		*)
			log_err "Unhandled packed format: $file"
			return 1
			;;
	esac

	echo "$path"
	return $ret
}

##############################################################################
#
# identity related stubs
#
##############################################################################

# Try to run as user
function user_run {
	typeset runas="$1"; shift
	typeset curruser="$(user_current)"
	typeset ret=0

set -x
	# Exec from stdin
	if [[ "$@" = "-" ]]; then
		
		# If no user specified, or we already are correct one...
		if [[ -z "$runas" ]] || [[ "$runas" = "$curruser" ]]; then
			eval "$(cat)" 98>&- 99>&-
			ret=$?
			
		# root... yay !
		elif [[ "$curruser" = "root" ]]; then
			cat | su -m "$runas" 98>&- 99>&-
			ret=$?
		else
			log_err "Cannot change from user $curruser to user $runas"
			ret=4
		fi
		
	# Standard binary to run
	else

		# No user specified, or already correct user
		if [[ -z "$runas" ]] || [[ "$runas" = "$curruser" ]]; then
			log_dbg "Using eval to run as '$runas' cmd: '$@'"
			eval "$@" 98>&- 99>&-
			ret=$?

		# root... yay !
		elif [[ "$curruser" = "root" ]]; then
			log_dbg "Using su to run as '$runas' cmd: '$*'"
			# I need to flatten
			su -m -c "$*" "$runas" 98>&- 99>&-
			ret=$?

		# Maybe handle sudo ?
		elif sret="$(sudo -nl 2>/dev/null|awk 'p==1; /may run the following commands/{p=1;}')" && [[ -n "$sret" ]]; then
			log_dbg "Using sudo to run as '$runas' cmd: '$@'"
			# maybe should parse $sret output more...
			sudo -n -u "$runas" "$@" 98>&- 99>&-
			ret=$?

		# Fails...
		else
			log_err "Cannot exec '$@' as user $runas from user $curruser"
			ret=4
		fi
	fi
set +x

	return $ret
}

function user_current {
	id -un
}

function user_owner {
	typeset file="$1"

	stat -c '%U' $file

}



##############################################################################
#
# Main service processing
#
##############################################################################

# Standard start
function amsvc_start {

	# Use global opts if available
	typeset opts="${RUN_OPTSTART:-}"
	typeset pidf=""

	# If argument provided, use these to override
	[[ -n "${1:-}" ]] && {
		opts="$@"
	}


	#
	# User defined startup func, just use it
	#
	if is_func "run_start"; then
		log_inf "Starting with custom run_start function"
		run_start "$opts"
		log_inf "Result: $?"
		return $?

	#
	# Variables defined for standard management
	#
	elif [[ -n "$RUN_BIN" ]]; then

		# Runas specified user. If not defined, use owner of the binary
		typeset runas="${RUN_USER:-$(stat -c '%U' "$RUN_BIN")}"

		#
		# PIDFILE management
		#
		[[ -n "$RUN_OPTPID" ]] && {
			pidf="$(amsvc_getpidfile)"
			opts+=" $RUN_OPTPID $pidf"
		}

		# If pidfile, check it has access to the file
		[[ -n "$pidf" ]] && [[ -e "$pidf" ]] && {

			# Does the file already belong to target user
			[[ "$(user_owner "$pidf")" != "$runas" ]] && {
				chown $runas: "$pidf" || {
					log_err "Unable to chown '$runas' '$pidf'. The app may fail or be unmanageable"
				}
			}
		}

		#
		# Logfile and daemon management
		#
		[[ -n "$RUN_DAEMON" ]] && {
			typeset logfile="$(amsvc_getlogfile)"
			log_inf "Daemonizing and sending logs to $logfile"
			opts+=" >>$logfile 2>&1 0>/dev/null &"
		}

		log_inf "Starting with \$RUN_BIN var ($RUN_BIN $opts)"
		typeset out=""
		typeset ret=""

		out="$(user_run "$RUN_USER" "$RUN_BIN" $opts 2>&1)"
		ret=$?


		# Check return value
		if [[ $ret -ne 0 ]]; then
			log_err "Service start return: $ret. Output:\n$out"
			log_dbg "$(log_stackdump)"
		else
			log_inf "Result: $ret"
		fi
		return $ret

	# Nothing...
	else
		log_err "Cannot use generic start: No function 'run_start' and no var 'RUN_BIN' defined"
		return 1
	fi

}

# Standard stop
function amsvc_stop {
	:
}

function amsvc_upgrade {
	typeset version_new="${1:-}"
	typeset version_old="$RUN_VERS"

	typeset r=0

	# Get the latest version if the helper provides it
	[[ -z "$version_new" ]] && {
		if is_func upgrade_getlatest; then
			log_wrn "No version specified. Trying to find latest version"
			version_new="$(upgrade_getlatest)"

			if [[ -n "$version_new" ]]; then
				log_inf "Found version '$version_new'"
			else
				log_err "Unable to get latest version. Stopping"
				return 1
			fi
		else
			log_err "No version specified and no helper 'upgrade_getlatest' defined"
			return 1
		fi
	}

	log_stepnew "Upgrading from '$version_old' to '$version_new'"

	# A target version must be provided.
	#[[ -z "$version_new" ]] && {
	#	log_err "cannot call amsvc_upgrade without a valid arg 1 (version)"
	#	return 99
	#}

	# Prepare / unpack the app
	if ! is_func upgrade_prepare "$version_new"; then
		log_err "Cannot upgrade without defined 'upgrade_prepare' function"
		return 1
	fi

	# Prepare the upgrade
	log_stepnew "Preparing app version $version_new"
	upgrade_prepare "$version_new" || {
		r=$?
		log_err "Upgrade_prepare failed. ReturnCode: $r"
	}
	log_stepend "Finished app preparation. Ret:$r"
	[[ $r -ne 0 ]] && return $r

	# Display the configuration difference
	log_stepnew "Upgrade: getting differences between config files"
	if is_func upgrade_confdiff; then
		upgrade_confdiff "$version_new" "$version_old"
		r=$?
		log_stepend "Diff done. Ret:$r"
	else
		log_stepend "No function 'upgrade_confdiff' declared. Skipping"
	fi

	# Try to setup the new config file
	log_stepnew "Upgrade: merging configuration files"
	if is_func upgrade_confmerge; then
		upgrade_confmerge "$version_new" "$version_old"
		r=$?
		log_stepend "Merge done. Ret:$r"
	else
		log_stepend "No function 'upgrade_confmerge' declared. Skipping"
	fi

	# Test the new version
	log_stepnew "Upgrade: Testing new version"
	if is_func upgrade_test; then
		upgrade_test "$version_new"
		r=$?
		log_stepend "test done. Ret:$r"
	else
		log_stepend "No function 'upgrade_test' declared. Skipping"
	fi

	log_stepend "Upgrade finished. Final result: $r"
	return $r
}



function amsvc_getpidfile {
	# Create base folder if needed
	[[ -d "$TMP_PIDS" ]] || mkdir -p "$TMP_PIDS"

	# Return standard pid path
	echo "${TMP_PIDS}/${APP_NAME}.pid"
}

function amsvc_getlogfile {
	[[ -d "$LOG_BASE" ]] || mkdir -p "$LOG_BASE"

	echo "$LOG_BASE/daemon.log"
}

function amsvc_isrunning {

	# Check if we have a valid PID File
	typeset pidfile="$(amsvc_getpidfile)"
	[[ -s "$pidfile" ]] && {
		typeset pid="$(cat "$pidfile" 2>/dev/null)"
		# PIDs < 100 are so unlikely (used by kthreads) we shouldn't even try
		[[ -n "$pid" ]] && [[ "$pid" -gt 100 ]] && {
			[[ -e "/proc/$pid" ]]
			return $?
		}
	}

	# No pid file, try if we have a RUN_BIN var
	[[ -n "$RUN_BIN" ]] && {
		:
	}

	return 1
}

# Main processing option
function amsvc_main {

	while [[ -n "${1:-}" ]]; do
		case $1 in
			-v|--verbose)
				LOG_VERB+=1
				shift
				;;

			*)
				break;
				;;
		esac
	done


	# Debugging logs (beware, will be async from other standard log_ calls !)
	#typeset -a LOG_DBGSTACK
	typeset LOG_DBGFILE="$LOG_BASE/svc.${APP_NAME}.$$.dbg"
	exec 98>&1 99> >(log_xtr)
	export PS4=' (${BASH_SOURCE##*/}::${FUNCNAME[0]:-main}::$LINENO)  '
	BASH_XTRACEFD=99




	typeset r=0
	typeset act="${1:-}"; shift

	#
	case "$act" in
		start)
			amsvc_isrunning && log_wrn "already started"
			amsvc_start "$@"
			r=$?
			;;
		stop)
			amsvc_isrunning || log_wrn "already stopped"
			amsvc_stop "$@"
			r=$?
			;;
		restart)
			amsvc_isrunning && amsvc_stop "$@"
			amsvc_isrunning || amsvc_start "$@"
			r=$?
			;;
		status)
			echo "Status of ${APP_NAME}:"
			amsvc_isrunning
			r=$?
			;;

		upgrade)
			amsvc_upgrade "$@"
			r=$?
			;;
		*)
			log_err "Usage: $0 <start|stop|restart|status|upgrade>"
			exit 1
			;;
	esac

	return $r
}

function file_set_key {
	:
}
